package com.ibm.icu.text;

import java.text.ParsePosition;




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class FractionalPartSubstitution
  extends NFSubstitution
{
  private static final String copyrightNotice = "Copyright Â©1997-1998 IBM Corp.  All rights reserved.";
  private boolean byDigits = false;
  




  private boolean useSpaces = true;
  







  private static final int MAXDECIMALDIGITS = 8;
  








  FractionalPartSubstitution(int pos, NFRuleSet ruleSet, RuleBasedNumberFormat formatter, String description)
  {
    super(pos, ruleSet, formatter, description);
    if ((description.equals(">>")) || (description.equals(">>>")) || (ruleSet == this.ruleSet)) {
      byDigits = true;
      if (description.equals(">>>")) {
        useSpaces = false;
      }
    } else {
      this.ruleSet.makeIntoFractionRuleSet();
    }
  }
  















  public void doSubstitution(double number, StringBuffer toInsertInto, int pos)
  {
    if (!byDigits) {
      super.doSubstitution(number, toInsertInto, pos);



    }
    else
    {


      int numberToFormat = (int)Math.round(transformNumber(number) * Math.pow(10.0D, 8.0D));
      



      boolean doZeros = false;
      for (int i = 0; i < 8; i++) {
        int digit = numberToFormat % 10;
        if ((digit != 0) || (doZeros)) {
          if ((doZeros) && (useSpaces)) {
            toInsertInto.insert(pos + this.pos, ' ');
          }
          doZeros = true;
          ruleSet.format(digit, toInsertInto, pos + this.pos);
        }
        numberToFormat /= 10;
      }
    }
  }
  





  public long transformNumber(long number)
  {
    return 0L;
  }
  




  public double transformNumber(double number)
  {
    return number - Math.floor(number);
  }
  






















  public Number doParse(String text, ParsePosition parsePosition, double baseValue, double upperBound, boolean lenientParse)
  {
    if (!byDigits) {
      return super.doParse(text, parsePosition, baseValue, 0.0D, lenientParse);
    }
    




    String workText = new String(text);
    ParsePosition workPos = new ParsePosition(1);
    double result = 0.0D;
    
    double p10 = 0.1D;
    
    while ((workText.length() > 0) && (workPos.getIndex() != 0)) {
      workPos.setIndex(0);
      int digit = ruleSet.parse(workText, workPos, 10.0D).intValue();
      if ((lenientParse) && (workPos.getIndex() == 0)) {
        digit = NumberFormat.getInstance().parse(workText, workPos).intValue();
      }
      
      if (workPos.getIndex() != 0) {
        result += digit * p10;
        p10 /= 10.0D;
        parsePosition.setIndex(parsePosition.getIndex() + workPos.getIndex());
        workText = workText.substring(workPos.getIndex());
        while ((workText.length() > 0) && (workText.charAt(0) == ' ')) {
          workText = workText.substring(1);
          parsePosition.setIndex(parsePosition.getIndex() + 1);
        }
      }
    }
    result = composeRuleValue(result, baseValue);
    return new Double(result);
  }
  







  public double composeRuleValue(double newRuleValue, double oldRuleValue)
  {
    return newRuleValue + oldRuleValue;
  }
  


  public double calcUpperBound(double oldUpperBound)
  {
    return 0.0D;
  }
  







  char tokenChar()
  {
    return '>';
  }
}
